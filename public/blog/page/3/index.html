
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Zientzilaria</title>
  <meta name="author" content="Paulo Nuin">

  
  <meta name="description" content="The chapter 3 review that I promised for &#8220;tomorrow&#8221; (last Saturday) was
lazily postponed until today. So, let&#8217;s get to it. Tarek in &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zientzilaria.genedrift.org/blog/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Zientzilaria" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Zientzilaria</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zientzilaria.genedrift.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2009/02/09/expert-python-programming-by-tarek-ziade-a-review-of-chapter-3/">Expert Python Programming by Tarek Ziadé - a review of Chapter 3</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-09T13:29:24-05:00" pubdate data-updated="true">Feb 9<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The chapter 3 review that I promised for &#8220;tomorrow&#8221; (last Saturday) was
lazily postponed until today. So, let&#8217;s get to it. Tarek in this chapter
continues with syntax best practices, but at this time at class level.
As expected the chapter requires that you have a minimal knowledge of
Python classes, so I can say it&#8217;s geared to somewhat experienced
programmers, and not to newcomers. There is a short explanation on
sub-classing that warms up things for the next sections. Next is the
built-in method (type?) <code>super</code>, which was new to me. Basically <code>super</code>
gives you access a method or attribute of a class by calling its parent
directly. This is a segue into understanding the Method Resolution Order
in Python, which is understanding which class has precedence over the
others. For me, I haven&#8217;t dealt with such structures before it was a
good and straight explanation, especially when he explains about
possible pitfalls of using <code>super</code>. A short list of best practices
helps:</p>

<ul>
<li><ul>
<li>Multiple inheritance should be avoided:</li>
</ul>
</li>
<li>super usage has to be consistent: Mixing super and classic calls is
a confusing practice.</li>
<li>Don&#8217;t mix old-style and new-style classes</li>
<li>Class hierarchy has to be looked over when a parent class is called</li>
</ul>


<p>After dealing with MRO, comes what I think is one of the best sections
of the book so far, where Tarek explains about object descriptors and
gives a little bit of the Python&#8217;s approach to introspection. This short
section is basically all code, but it&#8217;s good to have a good best
practices reference, including here properties and slots. The last part
of the chapter covers meta programming, and as Chris pointed in the
comments, that&#8217;s a difficult area of Python (maybe for the ones like me
that don&#8217;t have a CS formation). I would have to try the examples by
hand and maybe define areas in my code where I can use it, so to take
fully advantage and fully understand it. Overall, the chapter gives a
good series of topics about Python classes and I enjoyed learning a
little bit more things that I couldn&#8217;t understand previously. Next we
will see a review of chapter 4, that deals with PEP 8 and naming best
practices.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2009/02/06/expert-python-programming-by-tarek-ziade-a-review-of-chapter-2/">Expert Python Programming by Tarek Ziadé - a review of Chapter 2</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-06T11:08:03-05:00" pubdate data-updated="true">Feb 6<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.amazon.com/Beginning-Perl-Bioinformatics-James-Tisdall/dp/0596000804?SubscriptionId=0G81C5DAZ03ZR9WH9X82&amp;tag=zemanta-20&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=0596000804"><img src="http://ecx.images-amazon.com/images/I/41GpHIPgOlL._SL200_.jpg" title="Cover of &quot;Beginning Perl for Bioinformati..." alt="Cover of &quot;Beginning Perl for
Bioinformati..." /></a>
  ~ [Cover via</p>

<pre><code>Amazon](http://www.amazon.com/Beginning-Perl-Bioinformatics-James-Tisdall/dp/0596000804?SubscriptionId=0G81C5DAZ03ZR9WH9X82&amp;tag=zemanta-20&amp;linkCode=xm2&amp;camp=2025&amp;creative=165953&amp;creativeASIN=0596000804)
</code></pre>

<p>So we&#8217;re up to the second chapter of Tarek&#8217;s book. A short disclaimer
before diving into it. I started this blog, basically one year after I
had started programming with Python. The initial idea was to &#8220;convert&#8221;
the Beginning Perl for Bioinformatics book to Python and see what were
the advantages and disadvantages of both languages. I was far from being
a advanced Python programmer, and the inception of the blog helped me
getting close to that, even though I consider myself far from being an
expert programmer in Python. I learned a lot working on converting the
Perl and learned a lot from the comments and interaction with other
programmers and visitors of the blog. As anything in life one&#8217;s path is
long and tortuous and there&#8217;s nothing better than daily learning and
exercise. So, as I mentioned in the previous post, this book was
tailored for someone like me. I needed a boost on advanced Python
techniques and the second chapter just gave me that. Tarek writes in
this chapter about good syntax practices below the class level,
functions and methods that are common in daily usage. He starts with
list comprehensions, that we have seen in this site. It&#8217;s a short and
concise section and gives you exactly what you need about this
functionality. Next, iterators and generators. I had a little bit of
background on iterators, and have used them here and there, but not a
lot on generators. I learned a bit from this section, what you expect
from a book like this, things like the <code>close</code> and <code>throw</code>. Although
this was good first step on generators, I wished the section could be
longer, but that maybe not the focus of the book. Coroutines was a
completely new subject for me. Maybe I haven&#8217;t been diving into Python
as much as I needed to, but time is short these days and programming
Python is not the first objective of my work. The example is complete
and easy to understand, but again I wish it was a tad bit longer. Tarek
then explains a bit of generator expressions (list comprehension for
generators) and enters the itertools module. So far so good, it&#8217;s a nice
summary (at least for me) of simple techniques that can be incorporated
into daily coding. And then &#8230; Decorators. I blame on my poor CS skills
or maybe my whole background on programming, but I still cannot get
decorators. In my short-sighted view of the programming world I cannot
see a place, at least on the things I&#8217;m doing, where I can use a
decorator. And here comes the first criticism of the book: I still
cannot get after reading the section. One thing that would help a bit
would be to have colours on the examples and maybe go over them
explaining some code lines. But at the same time, I admit that this
might be a personal problem, where the concept of decorators don&#8217;t fit
into my brain, and maybe the focus of the book is to show this advanced
technique to someone that has a better grasp of the concept. Overall,
it&#8217;s a very good chapter and a good pointer to some expert/advanced
techniques in Python. Tomorrow, chapter 3, and we&#8217;re a going to see
classes.</p>

<p><a href="http://reblog.zemanta.com/zemified/2b86d192-b0ab-48fa-88ac-28aacbdf82e5/" title="Zemified by Zemanta"><img src="http://img.zemanta.com/reblog_e.png?x-id=2b86d192-b0ab-48fa-88ac-28aacbdf82e5" alt="Reblog this post [with
Zemanta]" /></a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2009/02/05/expert-python-programming-by-tarek-ziade-a-review-of-chapter-1/">Expert Python Programming by Tarek Ziadé - a review of Chapter 1</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-02-05T18:20:23-05:00" pubdate data-updated="true">Feb 5<span>th</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>I&#8217;ve bought (no, Packt Publishing didn&#8217;t send me a copy for review)
Tarek&#8217;s book quite sometime ago, but job changes, and extra-Python
issues kept me away from reading it with the attention if fully deserve.
When I saw the announcement, I thought that this was the book I wanted
in Python. First, a little bit of perspective. I&#8217;m a a biologist,
self-taught programmer/coder/you-name-it. I only had a brief course on
programming logic with Pascal in 1993 (I think). I first learned Basic
on Apple ][, then on PC, then moved to Visual Basic, Pascal, C and C++,
most of them with the help of books. About three and a half years ago, I
got tired of compiling things and decided to learn a different language
that would be more agile to code with. Not liking Perl, made me check
Python. And I got hooked. Of course as a lay programmer, I won&#8217;t discuss
why it&#8217;s better or worse than any other language using technical terms,
but I can say that Python fits my needs in fast and efficient
programming and I&#8217;m quite happy with the choice I&#8217;ve made. So, this
review will not be technical, but will try to expose the book&#8217;s
strengths and the weak parts. Chapter one gives a good introduction on
how to install Python and some nice pointers on how to program Python,
such as IDEs and initial settings you can add to it. Also there is a
short overview of the modern Python implementations. Is it a necessary
chapter? Yes and no. No, because the schooled Python user won&#8217;t need it,
his or her programming environment will already be installed,
configured, set and ready to go. Yes, because this chapter works as a
disclaimer for the not-so-experienced Python programmer, and shows
everyone of what is expected of this book and what standards will be
used. In my opinion, it&#8217;s a necessary starting point, so the author
knows that everyone is at the same level. This chapter is also a good
short summary of good practices of installing and setting up Python.
Tomorrow, chapter 2.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2009/01/31/bpforb-is-now-pep-8-compliant/">BPforB is now PEP 8 compliant!</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2009-01-31T12:51:10-05:00" pubdate data-updated="true">Jan 31<span>st</span>, 2009</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>As mentioned in the previous post, Robin Stocker kindly provided a git
patch with the required changes to all scripts stored on the repository
to be compliant with the PEP 8. The changes were mainly regarding
variable/object names, but they were important as make the code
available here more Pythonic following the rules of the Benevolent
Dictator for Life. I would like to thank Robin for spending his time
doing this. Much appreciated. Now, just a quick git tutorial on how to
apply patches: git apply __patch_file__ git commit -a -m &#8220;patch
applied&#8221; git push That&#8217;s it. Apply, commit, push and you&#8217;re done. The
repository is already updated.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/12/19/thats-it-for-2008/">That&#8217;s it for 2008</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-12-19T12:34:15-05:00" pubdate data-updated="true">Dec 19<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>The date came and is now gone, and I forgot to &#8220;celebrate&#8221; two years of
Beginning Python for Bioinformatics on December 13th. I would like to
thank everyone that commented, helped with posts and suggested anything
that would make this website better. Clearly it is far from being what I
wanted it to be, but slowly but surely we will get there. Thanks again
and I wish an excellent holiday season and a great 2009 to everyone! See
you in 2009.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/12/08/scripts-and-python-30-part-2-using-2to3/">Scripts and Python 3.0, part 2, using 2to3</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-12-08T14:55:56-05:00" pubdate data-updated="true">Dec 8<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>And we&#8217;re back to check our initial scripts to run on Python 3.0. Along
with this latest release, a nice tool to parse your scripts is also
installed. It&#8217;s called
<a href="http://docs.python.org/dev/3.0/library/2to3.html">2to3</a> and it&#8217;s
available in the <code>Tools/scripts</code> of your Python 3.o installation
directory. Basic usage is very similar to any python script: [sourcecode
language=&#8217;bash&#8217;]2to3 end. This will tell Python what we want the end of
the line, in our case an empty string. So the line would be [sourcecode
language=&#8217;python&#8217;]print(line, end = &#8221;)[/sourcecode] That&#8217;s it. So
code_03 and code_04 will be [sourcecode language=&#8217;python&#8217;]#code_03
import re #setting the DNA string myDNA = &#8216;ACGTTGCAACGTTGCAACGTTGCA&#8217;
#assigning a new regex and compiling it #to find all Ts regexp =
re.compile(&#8216;T&#8217;) #create a new string tha will receive #the regex
result with Us replacing Ts myRNA = regexp.sub(&#8216;U&#8217;, myDNA) print(myRNA)
#end 03 #code 04 #assigning a filename to a variable dnafile =
&#8220;AY162388.seq&#8221; #opening the file file = open(dnafile, &#8216;r&#8217;) #printing
each line of the file for line in file: print(line, end=&#8221;&#8220;)[/sourcecode]
Now, code_05, has 45 lines including comments, so it should be a good
idea to test 2to3 on it, especially after a long time since we created
the script. There might be some other changes that we might miss (I
already . Let&#8217;s run 2to3 on our original script and check the output:
<code>RefactoringTool: Skipping implicit fixer: buffer RefactoringTool: Skipping implicit fixer: idioms RefactoringTool: Skipping implicit fixer: set_literal RefactoringTool: Skipping implicit fixer: ws_comma --- code_05.py (original) +++ code_05.py (refactored) @@ -30,16 +30,16 @@  #the loop continues  while inputfromuser:      #raw_input received the user input as string -    inmotif = raw_input('Enter motif to search: ') +    inmotif = input('Enter motif to search: ')      #now we check for the size of the input      if len(inmotif) &gt;= 1:          #we compile a regex with the input given          motif = re.compile('%s' % inmotif)          #looking to see if the entered motif is in the sequence          if re.search(motif, sequence): -            print 'Yep, I found it' +            print('Yep, I found it')          else: -            print 'Sorry, try another one' +            print('Sorry, try another one')      else: -        print 'Done, thanks for using motif_search' +        print('Done, thanks for using motif_search')          inputfromuser = False RefactoringTool: Files that need to be modified: RefactoringTool: code_05.py</code>
So a lot of lines, seems that we need to do a lot of changes. But in
fact there are not many changes. All lines starting with a - need to be
removed and replaced by the lines starting with a +, and the + lines are
adjacent to the ones we need to change. Again, the most common changes
here are the print statements, but there is also another change to be
done [sourcecode language=&#8217;python&#8217;]inmotif = raw_input(&#8216;Enter motif to
search: &#8216;) inmotif = input(&#8216;Enter motif to search: &#8216;)[/sourcecode] So,
there is no <code>raw_input</code> in Python 3.0, it was abolished for a more
evolved <code>input</code> function that now always expect a string, that can be
evaluated later if needed (and desired), just like the old <code>raw_input</code>.
Now there is no confusion anymore on which one to use. Digging a little
bit into 2to3 we see that it can write the code for use by using the
<code>-w</code> parameter when running the script. Be careful as it rewrites the
same file, however saving a backup copy. In the end we get this code
from 2to3 (code_05.py) [sourcecode language=&#8217;python&#8217;]#!/usr/bin/env
python &#8221;&#8217; simple script to find motifs on DNA sequences using regex the
script is interactive &#8221;&#8217; # we use the RegEx module import re import
string #still keep the file fixed dnafile = &#8220;AY162388.seq&#8221; #opening
the file, reading the sequence and storing in a list seqlist =
open(dnafile, &#8216;r&#8217;).readlines() #let&#8217;s join the the lines in a temporary
string temp = &#8221;.join(seqlist) #assigning our sequence, with no
carriage returns to our #final variable/object sequence =
temp.replace(&#8216;\n&#8217;, &#8221;) #we start to deal with user input #first we
use a boolean variable to check for valid input inputfromuser = True
#while loop: while there is an motif larger than 0 #the loop continues
while inputfromuser: #raw_input received the user input as string
inmotif = input(&#8216;Enter motif to search: &#8216;) #now we check for the size
of the input if len(inmotif) >= 1: #we compile a regex with the input
given motif = re.compile(&#8216;%s&#8217; % inmotif) #looking to see if the entered
motif is in the sequence if re.search(motif, sequence): print(&#8216;Yep, I
found it&#8217;) else: print(&#8216;Sorry, try another one&#8217;) else: print(&#8216;Done,
thanks for using motif_search&#8217;) inputfromuser = False[/sourcecode] 2to3
seems to be pretty good in detecting changes, pointing them to you and
even writing the newer script for you. Until now I haven&#8217;t tested on big
scripts (more than 100 lines long), but I plan to do it soon. For small
scripts we saw that it works quite well. A good test for 2to3 would be
when we get to the motifs scripts that are a little bit more complex,
even though they are quite short. Stay tuned and check new code on the
repository.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/12/06/scripts-and-python-30-part-1/">Scripts and Python 3.0, part 1</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-12-06T11:07:08-05:00" pubdate data-updated="true">Dec 6<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Yes, Python 3.0 was released earlier than Perl &#8230; what version was it?
6? 7? Anyway, I decided to go back to most of the scripts that were
posted here. In the github repo we have 50 files in the &#8220;original
scripts&#8221; directory. Let&#8217;s check how do they fare on Python 3.0 and what
type of changes we need to do in order to make them work. Starting with
code_01.py, which is a couple of lines long [sourcecode
language=&#8217;python&#8217;]myDNA = &#8220;ACGTACGTACGTACGTACGTACGT&#8221; print
myDNA[/sourcecode] Here we have one of the most evident differences
between Python 2.x and 3.0. Now <code>print</code> is a <a href="http://docs.python.org/dev/3.0/whatsnew/3.0.html#print-is-a-function">function not a statement
anymore</a>,
so whatever we want to print now should be passed as a function
parameter. The above code would be changed to [sourcecode
language=&#8217;python&#8217;]myDNA = &#8220;ACGTACGTACGTACGTACGTACGT&#8221;
print(myDNA)[/sourcecode] That simple ins this case. But what are the
advantages of <code>print</code> being a function over a statement? More
flexibility, as can be seen in the link above. It is possible now to
send different parameters to print and make the output richer by
customizing separators between items, directing the output, etc. A
similar change would have to be made n our code_02.py. There are two
<code>print</code> statements there that should be translated to the function.
Trivial, so far. The original code [sourcecode language=&#8217;python&#8217;]myDNA =
&#8220;ACGTACGTACGTACGTACGTACGT&#8221; myDNA2 = &#8220;TCGATCGATCGATCGATCGA&#8221; print &#8220;First
and Second sequences&#8221; print myDNA, myDNA2 myDNA3 = myDNA + myDNA2 print
&#8220;Concatenated sequence&#8221; print myDNA3[/sourcecode] and to work on Python
3 [sourcecode language=&#8217;python&#8217;]myDNA = &#8220;ACGTACGTACGTACGTACGTACGT&#8221;
myDNA2 = &#8220;TCGATCGATCGATCGATCGA&#8221; print(&#8220;First and Second sequences&#8221;)
print(myDNA, myDNA2) myDNA3 = myDNA + myDNA2 print(&#8220;Concatenated
sequence&#8221;) print(myDNA3)[/sourcecode] This is would be the biggest (or
at least the most common) change that we would need to make in the
scripts posted here. Follow the repo to get the newer versions.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/11/19/creating-an-interface-for-the-motif-finding-script-final/">Creating an interface for the motif finding script, final</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-11-19T16:57:24-05:00" pubdate data-updated="true">Nov 19<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We can say that this would be our final version of the script. There are
many nice wxPython programming resources, and one is a very good book
called <a href="http://manning.com/rappin/">wxPython in Action</a>, which is
co-written by Robin Dunn, the wxPython maintainer. Go check it out. So
for the last entry in this series, we just need to add a couple of
changes to our interface and motif finding scripts. Basically on the
interface script we need to add a line that gets the value entered (or
the default one, if not changed) in the motif width input box. And we
can do that by including the line below in the <code>run_finder</code> function.
[sourcecode language=&#8217;python&#8217;]width =
self.motif_width.GetValue()[/sourcecode] This line tells the script to
get the value of the box and assign to the variable width. This method
will get whatever is inside the input box and save as a string to the
variable assigned. Now, we need to create the structure to actually send
this value to the motif finder functions. Last version of our function
<code>calculate_motifs</code> received two parameters, we need to add an extra one,
and also change the lines that call the function that get the quorums.
Basically the first lines of the function will be [sourcecode
language=&#8217;python&#8217;]def calculate_motifs(input_seqs, input_seqs2,
width): print input_seqs, input_seqs2 input_seqs =
fasta.read_seqs(open(input_seqs).readlines()) input_seqs2 =
fasta.read_seqs(open(input_seqs2).readlines()) foreground =
get_quorums(input_seqs, width) background = get_quorums(input_seqs2,
width)[/sourcecode] And that&#8217;s it. Our simple interface is ready to
primetime. OK, not prime primetime, we didn&#8217;t add a series of features
that will make it useful by everyone. For instance, there is no error
control, so someone could enter &#8216;ABC&#8217; in the width input box and that
value would be sent and an error will occur. Also you can click the run
button without any file selected. And we could go on and on. But this is
just a primer, and we can build from it. The code is on
<a href="http://github.com/nuin/beginning-python-for-bioinformatics/tree/master/scripts/motifs">Github</a>,
so get it there and have fun. Next time we will see &#8230; no plans yet.
We&#8217;ll see &#8230; Technorati Tags:
<a href="http://technorati.com/tag/wxPython">wxPython</a>,
<a href="http://technorati.com/tag/motifs">motifs</a>,
<a href="http://technorati.com/tag/Python">Python</a>,
<a href="http://technorati.com/tag/bioinformatics">bioinformatics</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/11/18/creating-an-interface-for-the-motif-finding-script-some-corrections/">Creating an interface for the motif finding script, some corrections</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-11-18T14:45:31-05:00" pubdate data-updated="true">Nov 18<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We need to pause a bit and do some corrections on our code. First the
code I posted on the last entry for the pymotif.py module is wrong. Ok,
not wrong, but some of the code I use to test ended up on the blog. Ths
first two lines of the calculate_motifs function contained a link to
the files I use for testing and should be replaced by [sourcecode
language=&#8217;python&#8217;]input_seqs =
fasta.read_seqs(open(input_seqs).readlines()) input_seqs2 =
fasta.read_seqs(open(input_seqs2).readlines())[/sourcecode] Also both
variables that store the filenames and paths in pymoteGUI.py are
declared in the wrong scope. The should have be declared at the pymotGUI
class level, so it is accessible to all the functions in that class.
This also means that every time we access the variable it should be
preceded by the class name in order for the interpreter to know where
the to get the value from. So both corrected files would be [sourcecode
language=&#8217;python&#8217;]#!/usr/bin/env python import wx import pymot import
pymotif import fasta import os class pymot(wx.App): def
__init__(self, redirect=False): wx.App.__init__(self, redirect)
class pymotGUI(wx.Frame): fore_file = &#8221; back_file = &#8221; def
__init__(self, parent, id): wx.Frame.__init__(self, parent, id,
&#8216;Python Motif Finder&#8217;, style=wx.DEFAULT_FRAME_STYLE)
self.__do_layout() def __do_layout(self): #adding the panel panel
= wx.Panel(self) #defines the menubar menubar = wx.MenuBar() #file
menu filemenu = wx.Menu() foreground_menu = filemenu.Append(-1, &#8216;Select
foreground file&#8217;) background_menu = filemenu.Append(-1, &#8216;Select
background file&#8217;) sep = filemenu.AppendSeparator() quitmenu =
filemenu.Append(-1, &#8216;Quit&#8217;) #appends the menu to the menubar and
creates it menubar.Append(filemenu, &#8216;File&#8217;) self.SetMenuBar(menubar)
#input box for motif width, and label self.one_label =
wx.StaticText(panel, -1, &#8216;Motif width&#8217;, (10,50)) self.motif_width =
wx.TextCtrl(panel, -1, &#8216;10&#8217;, (95, 50), (40,18)) #result textbox
self.results = wx.TextCtrl(panel, -1, &#8221;, (150, 50), (200, 100),
wx.TE_MULTILINE | wx.TE_AUTO_SCROLL | wx.HSCROLL) #run bbutton
self.run_button = wx.Button(panel, -1, &#8216;Run&#8217;, (10, 80)) #labels
self.fore_label = wx.StaticText(panel, -1, &#8216;Select the foreground
file&#8217;, (10, 10)) self.back_label = wx.StaticText(panel, -1, &#8216;Select the
background file&#8217;, (10, 30)) #binding the menus to functions
self.Bind(wx.EVT_MENU, self.on_foreground, foreground_menu)
self.Bind(wx.EVT_MENU, self.on_background, background_menu)
self.Bind(wx.EVT_BUTTON, self.run_finder, self.run_button) def
on_foreground(self, event): dialog = wx.FileDialog(self, style=wx.OPEN)
if dialog.ShowModal() == wx.ID_OK: pymotGUI.fore_file =
dialog.GetPath() self.fore_label.SetLabel(pymotGUI.fore_file) def
on_background(self, event): dialog = wx.FileDialog(self, style=wx.OPEN)
if dialog.ShowModal() == wx.ID_OK: pymotGUI.back_file =
dialog.GetPath() self.back_label.SetLabel(pymotGUI.back_file) def
run_finder(self, event): print pymotGUI.fore_file result =
pymotif.calculate_motifs(pymotGUI.fore_file, pymotGUI.back_file) for
motif in result: self.results.WriteText(motif + &#8216;n&#8217;) #wx.MessageBox(&#8216;It
should run, eh?&#8217;) #if __name__ == &#8216;__main__&#8217;: app = pymot()
frame = pymotGUI(parent=None, id = -1) #frame.CentreOnScreen()
frame.Show() app.MainLoop()[/sourcecode] and [sourcecode
language=&#8217;python&#8217;]#!/usr/bin/env python import fasta import sys from
collections import defaultdict def choose(n, k): if 0 &lt;= k &lt;= n: ntok =
1 ktok = 1 for t in xrange(1, min(k, n - k) + 1): ntok *= n ktok *= t
n -= 1 return ntok // ktok else: return 0 def get_quorums(seqs, mlen):
&#8221;&#8221;&#8221; add seq id_no to a set use explicit counter to create seq_no &#8220;&#8221;&#8221;
quorum = defaultdict(int) for seq in seqs: for n in range(len(seq) -
mlen): quorum[seq[n:n + mlen]] += 1 return quorum def
calculate_motifs(input_seqs, input_seqs2): print input_seqs,
input_seqs2 input_seqs =
fasta.read_seqs(open(input_seqs).readlines()) input_seqs2 =
fasta.read_seqs(open(input_seqs2).readlines()) foreground =
get_quorums(input_seqs, 10) background = get_quorums(input_seqs2,
10) N = len(input_seqs) + len(input_seqs2) res_motifs = [] for i in
foreground: term1 = choose(background[i], foreground[i]) term2 =
choose((N - background[i]), len(input_seqs) - 1) term3 = choose(N,
len(input_seqs)) p = (float(term1) * float(term2)) / term3 if 0 &lt; p &lt;=
0.0001: res_motifs.append(i + &#8216;t&#8217; + str(foreground[i]) + &#8216;t&#8217; +
str(background[i]) + &#8216;t&#8217; + str(p)) res_motifs.sort() return
res_motifs[/sourcecode] On the next post, the last in the series, we
will just check how to get the value from the width input box and
wrap-up everything. Technorati Tags:
<a href="http://technorati.com/tag/wxPython">wxPython</a>,
<a href="http://technorati.com/tag/python">python</a>,
<a href="http://technorati.com/tag/motifs">motifs</a>,
<a href="http://technorati.com/tag/GUI">GUI</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/11/13/creating-an-interface-for-the-motif-finding-script-part-8/">Creating an interface for the motif finding script, part 8</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-11-13T17:28:35-05:00" pubdate data-updated="true">Nov 13<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Let&#8217;s see now how do we connect our GUI to the the pymotif file (I
changed the name because of some conflicts with the app name [my bad!],
the git repo was updated accordingly). And also how to display the
results, in a simpler manner. Ok, first to connecting the script to the
function file, pymotif.py. The file is already imported in our script
and we have used it before. We need to find the exact point and which
parameters to pass. pytmotif.py is a slightly modified version of your
command line script, and the code is below. [sourcecode
language=&#8217;python&#8217;]#!/usr/bin/env python import fasta import sys from
collections import defaultdict def choose(n, k): if 0 &lt;= k &lt;= n: ntok =
1 ktok = 1 for t in xrange(1, min(k, n - k) + 1): ntok *= n ktok *= t
n -= 1 return ntok // ktok else: return 0 def get_quorums(seqs, mlen):
&#8221;&#8221;&#8221; add seq id_no to a set use explicit counter to create seq_no &#8220;&#8221;&#8221;
quorum = defaultdict(int) for seq in seqs: for n in range(len(seq) -
mlen): quorum[seq[n:n + mlen]] += 1 return quorum def
calculate_motifs(input_seqs, input_seqs2): input_seqs =
fasta.read_seqs(open(&#8216;celladhesion1000.fa&#8217;).readlines()) input_seqs2 =
fasta.read_seqs(open(&#8216;celladhesion1000C.fa&#8217;).readlines()) foreground =
get_quorums(input_seqs, 10) background = get_quorums(input_seqs2,
10) N = len(input_seqs) + len(input_seqs2) res_motifs = [] for i in
foreground: term1 = choose(background[i], foreground[i]) term2 =
choose((N - background[i]), len(input_seqs) - 1) term3 = choose(N,
len(input_seqs)) p = (float(term1) * float(term2)) / term3 if 0 &lt; p &lt;=
0.0001: res_motifs.append(i + &#8216;t&#8217; + str(foreground[i]) + &#8216;t&#8217; +
str(background[i]) + &#8216;t&#8217; + str(p)) res_motifs.sort() return
res_motifs[/sourcecode] So, basically the line we are interested is
this one [sourcecode language=&#8217;python&#8217;]def
calculate_motifs(input_seqs, input_seqs2):[/sourcecode] We replace
the wx.MessageBox line in our run_finder function and use the input
files selected by the user as parameters for calculate_motifs, and we
are done [sourcecode language=&#8217;python&#8217;]def run_finder(self, event):
result = pymotif.calculate_motifs(self.fore_file,
self.back_file)[/sourcecode] Very simple and direct. This should take
care of everything except the motif width, what we will see in the next
post. We still need a place to write the overrepresented motifs. We can
add a text box to the frame, and we do that by adding an extra
declaration in our __do_layout function. This time we need to add
some extra style to the box, so it can show multiple lines and has a
scroll bar. [sourcecode language=&#8217;python&#8217;]self.results =
wx.TextCtrl(panel, -1, &#8221;, (150, 50), (200, 100), wx.TE_MULTILINE |
wx.TE_AUTO_SCROLL | wx.HSCROLL)[/sourcecode] Notice the wx. flags
added. MULTILINE allows the box to have multiple lines and the other two
turn on the auto scroll and horizontal scroll. Great. And how do we
write the results. Notice above that the function that calculates the
motifs, returns a list where each item has the motif sequence and the p
value, sorted. So the only thing we need to do is to iterate over the
list and print each line to the result box. That simple, and we
accomplish it by using the WriteText method, that receives as a
parameter a string, either literal or a string object. Our run_finder
function will have a couple of extra lines [sourcecode
language=&#8217;python&#8217;]def run_finder(self, event): result =
pymotif.calculate_motifs(self.fore_file, self.back_file) for motif in
result: self.results.WriteText(motif + &#8216;n&#8217;)[/sourcecode] That will
present in a very simplistic way the resulting overrepresented motifs,
but it&#8217;s enough for now. Our GUI script will be [sourcecode
language=&#8217;python&#8217;]#!/usr/bin/env python import wx import pymot import
pymotif import fasta import os class pymot(wx.App): def
__init__(self, redirect=False): wx.App.__init__(self, redirect)
class pymotGUI(wx.Frame): def __init__(self, parent, id):
wx.Frame.__init__(self, parent, id, &#8216;Python Motif Finder&#8217;,
style=wx.DEFAULT_FRAME_STYLE) self.__do_layout() self.fore_file =
&#8221; self.back_file = &#8221; def __do_layout(self): #adding the panel
panel = wx.Panel(self) #defines the menubar menubar = wx.MenuBar()
#file menu filemenu = wx.Menu() foreground_menu = filemenu.Append(-1,
&#8216;Select foreground file&#8217;) background_menu = filemenu.Append(-1, &#8216;Select
background file&#8217;) sep = filemenu.AppendSeparator() quitmenu =
filemenu.Append(-1, &#8216;Quit&#8217;) #appends the menu to the menubar and
creates it menubar.Append(filemenu, &#8216;File&#8217;) self.SetMenuBar(menubar)
#input box for motif width, and label self.one_label =
wx.StaticText(panel, -1, &#8216;Motif width&#8217;, (10,50)) self.motif_width =
wx.TextCtrl(panel, -1, &#8216;10&#8217;, (95, 50), (40,18)) #result textbox
self.results = wx.TextCtrl(panel, -1, &#8221;, (150, 50), (200, 100),
wx.TE_MULTILINE | wx.TE_AUTO_SCROLL | wx.HSCROLL) #run bbutton
self.run_button = wx.Button(panel, -1, &#8216;Run&#8217;, (10, 80)) #labels
self.fore_label = wx.StaticText(panel, -1, &#8216;Select the foreground
file&#8217;, (10, 10)) self.back_label = wx.StaticText(panel, -1, &#8216;Select the
background file&#8217;, (10, 30)) #binding the menus to functions
self.Bind(wx.EVT_MENU, self.on_foreground, foreground_menu)
self.Bind(wx.EVT_MENU, self.on_background, background_menu)
self.Bind(wx.EVT_BUTTON, self.run_finder, self.run_button) def
on_foreground(self, event): dialog = wx.FileDialog(self, style=wx.OPEN)
if dialog.ShowModal() == wx.ID_OK: fore_file = dialog.GetPath()
self.fore_label.SetLabel(fore_file) def on_background(self, event):
dialog = wx.FileDialog(self, style=wx.OPEN) if dialog.ShowModal() ==
wx.ID_OK: back_file = dialog.GetPath()
self.back_label.SetLabel(back_file) def run_finder(self, event):
result = pymotif.calculate_motifs(self.fore_file, self.back_file) for
motif in result: self.results.WriteText(motif + &#8216;n&#8217;) #wx.MessageBox(&#8216;It
should run, eh?&#8217;) #if __name__ == &#8216;__main__&#8217;: app = pymot()
frame = pymotGUI(parent=None, id = -1) #frame.CentreOnScreen()
frame.Show() app.MainLoop()[/sourcecode]</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2010/12/01/why-i-left-biostar-but-i-still-like-stackoverflow/">Why I left Biostar, but I still like Stackoverflow</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/05/20/preview-of-django-1-1-testing-and-debugging/">Preview of Django 1.1 Testing and Debugging</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/05/01/initial-impressions-about-bioinformatics-programming-using-python/">Initial impressions about Bioinformatics Programming using Python</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/04/19/python-for-bioinformatics-by-sebastian-bassi-a-review/">Python for Bioinformatics by Sebastian Bassi: a (short) review</a>
      </li>
    
      <li class="post">
        <a href="/blog/2010/04/17/biostar-bioinformatics-community/">Biostar: bioinformatics community</a>
      </li>
    
  </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Paulo Nuin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
