
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Zientzilaria</title>
  <meta name="author" content="Paulo Nuin">

  
  <meta name="description" content="We keep on introducing Mike&#8217;s functions. This time there are a couple of
Python methods that we haven&#8217;t seen here and need some &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zientzilaria.genedrift.org/blog/page/21">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Zientzilaria" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Zientzilaria</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zientzilaria.genedrift.org" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/06/03/obtaining-overrerpresented-motifs-in-dna-sequences-part-8/">Obtaining overrerpresented motifs in DNA sequences, part 9</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-06-03T12:49:53-04:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We keep on introducing Mike&#8217;s functions. This time there are a couple of
Python methods that we haven&#8217;t seen here and need some introduction,
<code>izip</code> and <code>count</code>. To use these two we also need to import new modules</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span><span class="p">,</span> <span class="n">izip</span>
</span></code></pre></td></tr></table></div></figure>


<p> <code>count</code> returns consecutive integers starting at a
defined point (the method&#8217;s parameter). If empty it starts from zero.
Basically, by starting a <code>count</code> it will give an iterable with a
increasing integer values, in a fashion similar to a function with
yield. Every time our loop accesses the <code>count</code> it will &#8220;remember&#8221; the
last return value and increment it by one. <code>izip</code> also returns an
iterator, but from a list of iterables. It is basically used to iterate
through a list of many iterables at the same time. In the function below
it is used twice: one to generate a tuple (with <code>count</code>) with a sequence
number and the sequence itself. The sequence in the tuple is then used
in another <code>izip</code> to create the windows on the sequences to count
motifs.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_quorums_06</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'><span class="sd">&quot;&quot;&quot; add seq id\_no to a set use &#39;izip(count(),...) to create seq_no use</span>
</span><span class='line'><span class="sd">&#39;izip(count(),range(...)) to create start/stop indices for motifs &quot;&quot;&quot;</span>
</span><span class='line'>  <span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">id_no</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="n">seqs</span><span class="p">):</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">izip</span><span class="p">(</span><span class="n">count</span><span class="p">(),</span> <span class="nb">range</span><span class="p">(</span><span class="n">mlen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))):</span>
</span><span class='line'>          <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_no</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="n">quorum</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the next couple of posts we still be
checking motif quorum functions. Stay tuned.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/06/03/obtaining-overrepresented-motifs-in-dna-sequences-part-7/">Obtaining overrepresented motifs in DNA sequences, part 7</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-06-03T10:27:49-04:00" pubdate data-updated="true">Jun 3<span>rd</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Continuing on Mike&#8217;s functions to obtain motif quorums. We see function
3, 4 and 5. Function get_quorums_03, uses an old friend of the blog,
<code>sets</code>. Recall that <code>sets</code> are very similar to lists, but their are
unordered and items are unique.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_quorums_03</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>  <span class="sd">&quot;&quot;&quot; add seq id_no to a set use explicit counter to create seq_no &quot;&quot;&quot;</span>
</span><span class='line'>  <span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
</span><span class='line'>  <span class="n">id_no</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">:</span>
</span><span class='line'>      <span class="n">id_no</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">-</span><span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>          <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">mlen</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_no</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">quorum</span>
</span></code></pre></td></tr></table></div></figure>


<p> Basically,
the sequence numbers (an incremented counter) are added to a <code>defaultdict</code>
which was initialized as a set. This way you don&#8217;t need to check for the
existence of the sequence number in the <code>defaultdict</code> list and count on
the ability of <code>set</code> of being unique. Function 4 is very similar to
function 3 with the difference of using enumerate (as in function 02) to
make the sequence numbers.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_quorums_04</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>  <span class="sd">&quot;&quot;&quot; add seq id_no to a set use &#39;enumerate&#39; to create seq_no &quot;&quot;&quot;</span>
</span><span class='line'>  <span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">for</span> <span class="n">id_no</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seqs</span><span class="p">):</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">-</span><span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>          <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">mlen</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_no</span><span class="p">)</span>
</span><span class='line'>          
</span><span class='line'>  <span class="k">return</span> <span class="n">quorum</span>
</span></code></pre></td></tr></table></div></figure>


<p>Function 5
adds a twist, which is to have an enumerate to set the sequence range
(motif/word width) start and stop. This way the window is sliding based
on the tuple created by the enumerate method and not on the slicing that
were used in all other functions. Again, a <code>defaultdict</code> is initialized as
set and the sequence numbers are generated by an enumerate.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_quorums_05</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>  <span class="sd">&quot;&quot;&quot; add seq id_no to a set use &#39;enumerate&#39; to create seq_no use enumerate(range(...)) </span>
</span><span class='line'><span class="sd"> to create start/stop indices for motif &quot;&quot;&quot;</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">id_no</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seqs</span><span class="p">):</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">mlen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">))):</span>
</span><span class='line'>          <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">s</span><span class="p">:</span><span class="n">e</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">id_no</span><span class="p">)</span>
</span><span class='line'>          
</span><span class='line'>  <span class="k">return</span> <span class="n">quorum</span>
</span></code></pre></td></tr></table></div></figure>



</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/30/obtaining-overrepresented-motifs-part-6/">Obtaining overrepresented motifs in DNA sequences, part 6</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-30T21:30:44-04:00" pubdate data-updated="true">May 30<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We will take a break on developing the statistical module to obtain
overrepresented motifs (I will introduce mul in the next stats post),
and take a deeper look at the possibilities on obtaining the motif
quorums. Mike DeHaemer, a regular commenter and contributor to the blog,
sent me a <a href="http://python.org/" title="Python (programming language)">Python</a>
script with 8 different ways distributed in 13 distinct functions for
obtaining the motif quorums.</p>

<p>I will take advantage of his contribution
and post all of them, with some quick comments on each one of them (his
code comments were kept in each function). After, a small benchmarking
will be posted. Most of the functions need to import a couple of module</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span><span class="p">,</span> <span class="n">izip</span><span class="p">,</span> <span class="n">tee</span>
</span></code></pre></td></tr></table></div></figure>


<p>and they have two
parameters, a sequence list and the length of the motifs. The first
function uses again the <code>defaultdict</code> and it is very similar to the one
used in the final version of the quorum script. The <code>defaultdict</code> is
initialized as a list and the ids are added to a the list, keys are
motifs, only if they are not already present in it. The sequence id is
generated in a variable incremented each time the loop iterates.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_quorums_01</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>  <span class="sd">&quot;&quot;&quot;append seq id_no to list after checking to see if already present use explicit counter to create seq_no &quot;&quot;&quot;</span>
</span><span class='line'>  <span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span><span class='line'>  <span class="n">id_no</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">for</span> <span class="n">seq</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">:</span>
</span><span class='line'>      <span class="n">id_no</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>          <span class="k">if</span> <span class="nb">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">mlen</span><span class="p">]]:</span> <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="n">mlen</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_no</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">quorum</span>
</span></code></pre></td></tr></table></div></figure>


<p>The second function is very similar to the
first one, with the caveat that sequence id numbers are generated with
<code>enumerate</code>.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">get_quorums_02</span><span class="p">(</span><span class="n">seqs</span><span class="p">,</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>  <span class="sd">&quot;&quot;&quot; append seq id_no to list after checking to see if already present use &#39;enumerate&#39; to create seq_no &quot;&quot;&quot;</span>
</span><span class='line'>  <span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="n">id_no</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seqs</span><span class="p">):</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">-</span> <span class="n">mlen</span><span class="p">):</span>
</span><span class='line'>          <span class="k">if</span> <span class="n">id_no</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">mlen</span><span class="p">]]:</span>
</span><span class='line'>              <span class="n">quorum</span><span class="p">[</span><span class="n">seq</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="n">mlen</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_no</span><span class="p">)</span>
</span><span class='line'>              
</span><span class='line'>  <span class="k">return</span> <span class="n">quorum</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>enumerate</code> is a object based on another iterable object. When called
<code>enumerate</code> always returns a tuple of an indexed series. For instance,
in our case above, enumerate will return a series of tuples
<code>(0, sequence1), (1, sequence2) ... (n, sequenceN)</code>. That&#8217;s the reason
the enumerate loop uses a tuple as its index</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">for</span> <span class="n">id_no</span><span class="p">,</span> <span class="n">seq</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seqs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Next couple of posts will cover the other functions sent by Mike. Then we
will go back to the statistical module.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/26/processing-and-duplicons-on-human-chromosomes/">Processing and duplicons on human chromosomes</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-26T12:38:24-04:00" pubdate data-updated="true">May 26<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Thanks to <a href="http://freelancingscience.com/">Pawel</a>, I got introduced to the world of <a href="http://processing.org">Processing</a> and I must say I am impressed. It is a nice tool to create nice data displays. In the picture below I used a source code that Pawel sent me modified to display duplicons (larger than 30 kilobases) blast hits (larger than 5 kilobases) on a small arm of an <a href="http://en.wikipedia.org/wiki/Chromosome">human chromosome</a>. Of course due to the number of blast hits, different duplicons involved and the chromosome arm&#8217;s length (60 Mb) the arcs and the colours are not easy to format. But still there is a good amount of information regarding hit identity and similar duplicons in different chromosomal regions.</p>

<p><img src="http://www.genedrift.org/6p5k_arc_colorido.png" alt="Processing and duplicons on human chromosome" /></p>

<p><a href="http://www.zemanta.com/"><img src="http://img.zemanta.com/pixie.png?x-id=f5bdfda8-7286-4eba-a860-36bedb89f754" alt="" /></a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/23/thats-not-a-good-example-kaka/">That&#8217;s not a good example Kaká &#8230;</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-23T08:04:54-04:00" pubdate data-updated="true">May 23<span>rd</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>AC Milan&#8217;s player is <a href="http://msn.foxsports.com/soccer/story/8169594/AC-Milan%27s-Kaka-to-have-arthroscopic-knee-surgery">going to have arthroscopic knee surgery</a>. That&#8217;s really strange, because he is a member of the <a href="http://en.wikipedia.org/wiki/Igreja_Renascer_em_Cristo">Reborn in Christ Church</a> (Renascer in Portuguese), and usually they perform &#8221;<a href="http://www.youtube.com/watch?v=4NGpQE3bdso">cure sessions</a>&#8221; on TV to whoever send them money. C&#8217;mon Kaká you don&#8217;t need those bloody doctors to cure you, just ask around.</p>

<p><a href="http://www.zemanta.com/"><img src="http://img.zemanta.com/pixie.png?x-id=0d532e18-175f-4049-ac59-013767c0d246" alt="" /></a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/21/how-british/">How British &#8230;</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-21T16:20:22-04:00" pubdate data-updated="true">May 21<span>st</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Champions League final gets to penalty shots. If the old <a href="http://en.wikipedia.org/wiki/Corinthian_F.C.">Corinthian</a> was part of this match the result would be already defined.</p>

<p>From the ESPN live commentary:</p>

<blockquote><p>How fitting perhaps that the Champions League final between two English sides should end in a pathetic bout of chest-bumping and disrespect. It&#8217;s been a big issue all year in England and now it&#8217;s two best sides have betrayed the Premier League with their self-indulgent griping and petulance. Crazy.</p></blockquote>

<p><a href="http://www.zemanta.com/"><img src="http://img.zemanta.com/pixie.png?x-id=dea35fa3-0f50-43aa-a52c-c8c5ad84b672" alt="" /></a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/21/obtaining-overrepresented-motifs-in-dna-sequences-part-iv/">Obtaining overrepresented motifs in DNA sequences, part 5</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-21T13:50:00-04:00" pubdate data-updated="true">May 21<span>st</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Now that we have the script to generate the word quorums working (and
working fast!) we need then to calculate the a <em>p</em> value for each motif
based on the fore and background quorums. A <em>p</em> value cut-off will
determine the statistically significant words, or overrepresented. These
overrepresented words then can be analysed in more details (that we
won&#8217;t see here) and for instance determine new or already known
transcription factor binding sites. A well established statistical
method to determine such overrepresented words is the <a href="http://www.mnlottery.com/hypergeo.html">Hypergeometric Distribution</a> (HD for short).</p>

<p>HD
measures &#8220;success&#8221; and &#8220;failures&#8221; for values that do not fit in the
<a href="http://en.wikipedia.org/wiki/Binomial_distribution" title="Binomial distribution">binomial distribution</a>,
and depend on the measurements without replacement. Basically, HD&#8217;s
equation has a a series of binomial coefficients/combinations <img src="http://www.genedrift.org/hd.gif" alt="HD equation" /> where <em>N</em> is the population
size, <em>m</em> is foreground cluster size, <em>k</em> is the motif quorum in the
background gene set and <em>x</em> is the word quorum in the foreground set.
Note that the above equation is for the cumulative HD, where a sum of
probabilities is calculated. All the combinations in the above equation
have to be expanded to factorials that depending on the value to be
calculated are very computer intensive and sometimes don&#8217;t fit in the
memory (either a float or integer).</p>

<p>But
<a href="http://python.org/" title="Python (programming language)">Python</a> is able to
handle very large numbers and the calculation of large factorials is
relatively fast. In C++, I had to use a couple of tricks to achieve a
good speed in the factorial determination, and specially in the HD
calculation that requires multiple factorials and multiplication,
division and subtraction of large numbers. I didn&#8217;t want to use any
mathematical trick such as <a href="http://en.wikipedia.org/wiki/Stirling's_approximation" title="Stirling's approximation">Stirling&#8217;s approximation</a>.</p>

<p>13! in C++ already blows the size of long, so I had to use the <a href="http://www.tc.umn.edu/~ringx004/mapm-main.html">MAPM, A Portable Arbitrary Precision Math Library in C</a>. This library is
quite fast to calculate the factorial values but when one needs to
calculate more than 200,000 factorials the speed is unbearable. So, I
decided to pre-calculate a series of factorial values, keeping 10
decimal places as precision and saving in another column their
exponential. Then using this table as an input I was able to multiply,
divide and subtract the factorials and by employing the first law of
exponents do the same operations with their exponential.</p>

<p>This speeds up
the process tremendously. In Python, we don&#8217;t need any extra third-party
library, we just use Python itself, without importing an extra module. A
factorial function in Python can be written in one line, but for clarity
is better to define it separately. We can try throwing any number at it
and see the result.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'> <span class="k">def</span> <span class="nf">fac</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
</span><span class='line'>  <span class="n">value</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="p">:</span> <span class="n">i</span> \<span class="o">*</span> <span class="n">j</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">value</span>
</span></code></pre></td></tr></table></div></figure>


<p>We already saw <code>reduce</code> and <code>lambda</code> and using these two methods make
the factorial function clear and simple. And why are we not using a
recursive function? Because Python has a limit recursion depth (1000).
Next time we will implement the code that calculates the HD <em>p</em> values.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/12/obtaining-overrepresented-motifs-in-dna-sequences-part-4/">Obtaining overrepresented motifs in DNA sequences, part 4</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-12T14:35:13-04:00" pubdate data-updated="true">May 12<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We found a way to make the Python script as good as or better than the
C++ executable. But for the analysis we need to do, motif counts are not
the value we want. We need the quorum: the number of sequences the motif
is present at least once. For instance, if the desired motifs was
<code>AAACCCTTTG</code> we will check in which sequences this word was present. Let&#8217;s
say in a cluster of 10 sequences, we would find it in sequences 1, 2, 3,
4 and 5, giving us a quorum of 5 out of 10, or 50%. The quorum will be
used in the future in the statistical calculation in order to determine
the overrepresented motifs. With only a couple of modifications, we can
adapt the script used to get the motif counts to get the quorum.</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/scratch/python/bin/python </span>
</span><span class='line'>
</span><span class='line'><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">sys</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">fasta</span>
</span><span class='line'>
</span><span class='line'><span class="n">seqs</span> <span class="o">=</span> <span class="n">fasta</span><span class="o">.</span><span class="n">get_seqs</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>
</span><span class='line'><span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</span><span class='line'><span class="n">quorum</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">seq_number</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">seqs</span><span class="p">:</span>
</span><span class='line'>  <span class="n">seq_number</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">sequence</span><span class="p">)</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="p">)):</span>
</span><span class='line'>      <span class="k">if</span> <span class="ow">not</span> <span class="n">seq_number</span> <span class="ow">in</span> <span class="n">quorum</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">length</span><span class="p">]]:</span>
</span><span class='line'>          <span class="n">quorum</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">sequence</span><span class="p">[</span><span class="n">n</span> <span class="p">:</span> <span class="n">n</span> <span class="o">+</span> <span class="n">length</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seq</span>\<span class="n">_number</span><span class="p">)</span>
</span><span class='line'>          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">quorum</span><span class="p">:</span>
</span><span class='line'>              <span class="k">print</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="nb">len</span><span class="p">(</span><span class="n">quorum</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure>


<p> Basically, we change the way the
<code>defaultdict</code> is initialized, this time as a list instead of int and we
also change the procedure that used to get the counts. The loop does
identical work, iterating along the sequences, with a window (of the
input length) sliding on them and checking each word. This time instead
of incrementing the value of the <code>defaultdict</code>, we append to the list
the sequence number, obtained from a index integer variable (incremented
in each iteration of the loop), if this number is not already in the
list value. In the end each value of <code>quorum</code> will be a list os numbers
and by printing the list length we obtain the quorum. Testing the above
script there is no performance loss when comparing to the previous count
script. Next we will see which statistical method to use and start to
devising an script to calculate it.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/12/obtaining-overrepresented-motifs-in-dna-sequences-part-3/">Obtaining overrepresented motifs in DNA sequences, part 3</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-12T13:16:29-04:00" pubdate data-updated="true">May 12<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>We take a break of developing code and check for performance (non-scientific testing!).</p>

<p>In the previous entry a simple file was used
as input: 8 DNA sequences of 500 bases each. That&#8217;s not enough to test
the performance of the Python script against the C++ compiled
executable. So, we use a larger file; two larger files to be more exact.</p>

<p>First, we use a 555 sequence file with the sequences averaging 19371
nucleotides and another with 3854 sequences averaging 20000 nucleotides
in length.</p>

<p>Those files were the largest foreground and background
clusters used in analysis. Let&#8217;s see how the Pyhton and C++ fared
(Linux&#8217;s time was used in the comparison, for simplicity).</p>

<p><strong>Foreground cluster</strong> Average of 10 runs <br/>
C++: 45.66 seconds<br/>
Python: 36.4 seconds</p>

<p><strong>Background cluster</strong> Average of 10 runs <br/>
C++: 5 minutes and 4 seconds<br/>
Python: 2 minutes and 44 seconds</p>

<p>The C++ analysis of the background
cluster was done on a cluster&#8217;s node, and not on my desktop computer,
due to the fact that my desktop could not handle it. C++ defense: the
code was developed by me and I am not a computer scientist. Clearly
there is room for improvement and performance gain. But, definitely we
can see that by using some advanced techniques in Python we are able to
outperform C++ (at least C++ code developed by me) and still have a
short and easy to read script. Next time we will change the Python&#8217;s
script output.</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2008/05/12/a-new-religion/">A new religion?</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2008-05-12T07:43:05-04:00" pubdate data-updated="true">May 12<span>th</span>, 2008</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.flickr.com/photos/43167867@N00/2486421088/"><img src="http://farm4.static.flickr.com/3154/2486421088_6a66097776_m.jpg" alt="After rainy day" /></a>Image from <a href="http://www.flickr.com/photos/43167867@N00/2486421088/">Flickr</a>I bet that in five years, a new <a href="http://scienceblogs.com/pharyngula/">religion will be formed</a>, albeit unintentionally (I am not 100% sure about the &#8220;unintentionally&#8221;).</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/22/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/20/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2011/09/06/goodbye-and-so-long/">Goodbye and so long</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/03/06/testing-feed/">Testing feed</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/02/23/scientists-are-human-beings/">Scientists are human beings</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/02/16/a-plea-to-mankind-news-outlets-and-even-scientists/">A plea to mankind, news outlets and even scientists</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/02/15/there-are-idiots-everywhere/">There are idiots everywhere &#8230;</a>
      </li>
    
  </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Paulo Nuin -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
